<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [async-call-rpc](./async-call-rpc.md) &gt; [AsyncGeneratorCall](./async-call-rpc.asyncgeneratorcall.md)

## AsyncGeneratorCall() function

The async generator version of the AsyncCall

<b>Signature:</b>

```typescript
export declare function AsyncGeneratorCall<OtherSideImplementedFunctions = {}>(thisSideImplementation: object | Promise<object> | undefined, options: AsyncCallOptions): _AsyncGeneratorVersionOf<OtherSideImplementedFunctions>;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  thisSideImplementation | object \| Promise&lt;object&gt; \| undefined | The implementation when this AsyncCall acts as a JSON RPC server. |
|  options | [AsyncCallOptions](./async-call-rpc.asynccalloptions.md) | [AsyncCallOptions](./async-call-rpc.asynccalloptions.md) |

<b>Returns:</b>

\_AsyncGeneratorVersionOf&lt;OtherSideImplementedFunctions&gt;

## Remarks

Warning: Due to technical limitation, AsyncGeneratorCall will leak memory. Use it at your own risk.

To use AsyncGeneratorCall, the server and the client MUST support the following JSON RPC internal methods which is pre ECMAScript async generator semantics:

- `rpc.async-iterator.start`

- `rpc.async-iterator.next`

- `rpc.async-iterator.return`

- `rpc.async-iterator.throw`

## Example


```ts
const server = {
     async *generator() {
         let last = 0
         while (true) yield last++
     },
}
type Server = typeof server
const serverRPC = AsyncGeneratorCall<Server>({}, { channel })
async function main() {
     for await (const x of serverRPC.generator()) {
         console.log('Server yielded number', x)
     }
}

```

